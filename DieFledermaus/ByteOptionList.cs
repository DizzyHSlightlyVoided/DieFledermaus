#region BSD license
/*
Copyright © 2015, KimikoMuffin.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.
3. The names of its contributors may not be used to endorse or promote
   products derived from this software without specific prior written
   permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#endregion
// !---- NOTE: This file was generated by a tool. Changes to this file without changing the corresponding template file may be list. ----!

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using DieFledermaus.Globalization;

namespace DieFledermaus
{
#if NOARG3
    using ArgumentOutOfRangeException = DieFledermaus.ArgumentOutOfRangeException3;
#endif
    [DebuggerDisplay(DieFledermausStream.CollectionDebuggerDisplay)]
    [DebuggerTypeProxy(typeof(DebugView))]
    internal class ByteOptionList : ICollection<FormatEntry>
#if IREADONLY
        , IReadOnlyCollection<FormatEntry>
#endif
    {
        private List<FormatEntry> _items;

        #region Constructors
        public ByteOptionList()
        {
            _items = new List<FormatEntry>();
        }

        public ByteOptionList(BinaryReader reader)
        {
            int itemCount = reader.ReadUInt16();

            _items = new List<FormatEntry>(itemCount);

            for (int i = 0; i < itemCount; i++)
                _items.Add(new FormatEntry(reader));
        }
        #endregion

        public bool IsReadOnly
        {
            get { return _items.Count >= ushort.MaxValue; }
        }

        public int Count
        {
            get { return _items.Count; }
        }

        #region Add
        public void Add(FormatEntry value)
        {
            if (IsReadOnly)
                throw new NotSupportedException();
            _items.Add(value);
        }

        public void Add(string key, ushort version)
        {
            Add(new FormatEntry(key, version));
        }

        public void Add(string key, ushort version, byte[] value)
        {
            Add(new FormatEntry(key, version, value));
        }

        public void Add(string key, ushort version, string s)
        {
            Add(new FormatEntry(key, version, s));
        }

        public void Add(string key, ushort version, short value)
        {
            Add(new FormatEntry(key, version, value));
        }

        public void Add(string key, ushort version, ushort value)
        {
            Add(new FormatEntry(key, version, value));
        }

        public void Add(string key, ushort version, int value)
        {
            Add(new FormatEntry(key, version, value));
        }

        public void Add(string key, ushort version, uint value)
        {
            Add(new FormatEntry(key, version, value));
        }

        public void Add(string key, ushort version, long value)
        {
            Add(new FormatEntry(key, version, value));
        }

        public void Add(string key, ushort version, ulong value)
        {
            Add(new FormatEntry(key, version, value));
        }

        public void Add(string key, ushort version, float value)
        {
            Add(new FormatEntry(key, version, value));
        }

        public void Add(string key, ushort version, double value)
        {
            Add(new FormatEntry(key, version, value));
        }
        #endregion

        public void Clear()
        {
            _items.Clear();
        }

        public bool Contains(FormatEntry item)
        {
            return _items.Contains(item);
        }

        public void CopyTo(FormatEntry[] array, int arrayIndex)
        {
            _items.CopyTo(array, arrayIndex);
        }

        public bool Remove(FormatEntry item)
        {
            return _items.Remove(item);
        }

        public IEnumerator<FormatEntry> GetEnumerator()
        {
            return _items.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return _items.GetEnumerator();
        }

        public void Write(BinaryWriter writer)
        {
            writer.Write((ushort)_items.Count);
            for (int i = 0; i < _items.Count; i++)
                _items[i].Write(writer);
        }

        public long GetSize()
        {
            long result = 0;
            for (int i = 0; i < _items.Count; i++)
                result += _items[i].GetSize();
            return result;
        }

        public FormatEntry[] ToArray()
        {
            return _items.ToArray();
        }

        private class DebugView
        {
            private ByteOptionList _optionList;

            public DebugView(ByteOptionList optionList)
            {
                _optionList = optionList;
            }

            [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
            public FormatEntry[] Items
            {
                get { return _optionList.ToArray(); }
            }
        }
    }

    /// <summary>
    /// Represents all elements in a format-list.
    /// </summary>
    [DebuggerTypeProxy(typeof(DebugView))]
    public class FormatEntry : IList<FormatValue>, IList
#if IREADONLY
        , IReadOnlyList<FormatValue>
#endif
    {
        private List<FormatValue> _values;
        internal static readonly UTF8Encoding TextEncoding = new UTF8Encoding(false, true);

        #region Constructors
        /// <summary>
        /// Creates a new instance with the specified key and version.
        /// </summary>
        /// <param name="key">The key to set.</param>
        /// <param name="version">The current version of the byte value.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="key"/> has a length of 0 or is greater than 65536 UTF-8 bytes.</para>
        /// <para>-OR-</para>
        /// <para><paramref name="version"/> is 0.</para>
        /// </exception>
        public FormatEntry(string key, ushort version)
        {
            if (key == null) throw new ArgumentNullException(nameof(key));
            if (key.Length == 0 || TextEncoding.GetByteCount(key) > DieFledermausStream.Max16Bit)
                throw new ArgumentOutOfRangeException(nameof(key), key, TextResources.CommentLength);
            if (version == 0)
                throw new ArgumentOutOfRangeException(nameof(version), version, TextResources.OutOfRangeVersion);

            _key = key;
            _version = version;
            _values = new List<FormatValue>();
        }

        /// <summary>
        /// Creates a new instance with the specified key, version, and initial value.
        /// </summary>
        /// <param name="key">The key to set.</param>
        /// <param name="version">The current version of the byte value.</param>
        /// <param name="value">The value to add.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> or <paramref name="value"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="key"/> has a length of 0 or greater than 65536 UTF-8 bytes.</para>
        /// <para>-OR-</para>
        /// <para><paramref name="value"/> has a length of 0 or greater than 65536.</para>
        /// <para>-OR-</para>
        /// <para><paramref name="version"/> is 0.</para>
        /// </exception>
        public FormatEntry(string key, ushort version, byte[] value)
            : this(key, version)
        {
            Add(value);
        }

        /// <summary>
        /// Creates a new instance with the specified key, version, and initial value.
        /// </summary>
        /// <param name="key">The key to set.</param>
        /// <param name="version">The current version of the byte value.</param>
        /// <param name="s">The value to add.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> or <paramref name="s"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="key"/> or <paramref name="s"/> has a length of 0 or greater than 65536 UTF-8 bytes.</para>
        /// <para>-OR-</para>
        /// <para><paramref name="version"/> is 0.</para>
        /// </exception>
        /// <exception cref="EncoderFallbackException">
        /// <paramref name="s"/> contains invalid characters.
        /// </exception>
        public FormatEntry(string key, ushort version, string s)
            : this(key, version)
        {
            Add(s);
        }

        /// <summary>
        /// Creates a new instance with the specified key, version, and initial value.
        /// </summary>
        /// <param name="key">The key to set.</param>
        /// <param name="version">The current version of the byte value.</param>
        /// <param name="value">The value to add.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="key"/> has a length of 0 or greater than 65536 UTF-8 bytes.</para>
        /// <para>-OR-</para>
        /// <para><paramref name="version"/> is 0.</para>
        /// </exception>
        public FormatEntry(string key, ushort version, short value)
            : this(key, version)
        {
            Add(value);
        }

        /// <summary>
        /// Creates a new instance with the specified key, version, and initial value.
        /// </summary>
        /// <param name="key">The key to set.</param>
        /// <param name="version">The current version of the byte value.</param>
        /// <param name="value">The value to add.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="key"/> has a length of 0 or greater than 65536 UTF-8 bytes.</para>
        /// <para>-OR-</para>
        /// <para><paramref name="version"/> is 0.</para>
        /// </exception>
        public FormatEntry(string key, ushort version, ushort value)
            : this(key, version)
        {
            Add(value);
        }

        /// <summary>
        /// Creates a new instance with the specified key, version, and initial value.
        /// </summary>
        /// <param name="key">The key to set.</param>
        /// <param name="version">The current version of the byte value.</param>
        /// <param name="value">The value to add.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="key"/> has a length of 0 or greater than 65536 UTF-8 bytes.</para>
        /// <para>-OR-</para>
        /// <para><paramref name="version"/> is 0.</para>
        /// </exception>
        public FormatEntry(string key, ushort version, int value)
            : this(key, version)
        {
            Add(value);
        }

        /// <summary>
        /// Creates a new instance with the specified key, version, and initial value.
        /// </summary>
        /// <param name="key">The key to set.</param>
        /// <param name="version">The current version of the byte value.</param>
        /// <param name="value">The value to add.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="key"/> has a length of 0 or greater than 65536 UTF-8 bytes.</para>
        /// <para>-OR-</para>
        /// <para><paramref name="version"/> is 0.</para>
        /// </exception>
        public FormatEntry(string key, ushort version, uint value)
            : this(key, version)
        {
            Add(value);
        }

        /// <summary>
        /// Creates a new instance with the specified key, version, and initial value.
        /// </summary>
        /// <param name="key">The key to set.</param>
        /// <param name="version">The current version of the byte value.</param>
        /// <param name="value">The value to add.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="key"/> has a length of 0 or greater than 65536 UTF-8 bytes.</para>
        /// <para>-OR-</para>
        /// <para><paramref name="version"/> is 0.</para>
        /// </exception>
        public FormatEntry(string key, ushort version, long value)
            : this(key, version)
        {
            Add(value);
        }

        /// <summary>
        /// Creates a new instance with the specified key, version, and initial value.
        /// </summary>
        /// <param name="key">The key to set.</param>
        /// <param name="version">The current version of the byte value.</param>
        /// <param name="value">The value to add.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="key"/> has a length of 0 or greater than 65536 UTF-8 bytes.</para>
        /// <para>-OR-</para>
        /// <para><paramref name="version"/> is 0.</para>
        /// </exception>
        public FormatEntry(string key, ushort version, ulong value)
            : this(key, version)
        {
            Add(value);
        }

        /// <summary>
        /// Creates a new instance with the specified key, version, and initial value.
        /// </summary>
        /// <param name="key">The key to set.</param>
        /// <param name="version">The current version of the byte value.</param>
        /// <param name="value">The value to add.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="key"/> has a length of 0 or greater than 65536 UTF-8 bytes.</para>
        /// <para>-OR-</para>
        /// <para><paramref name="version"/> is 0.</para>
        /// </exception>
        public FormatEntry(string key, ushort version, float value)
            : this(key, version)
        {
            Add(value);
        }

        /// <summary>
        /// Creates a new instance with the specified key, version, and initial value.
        /// </summary>
        /// <param name="key">The key to set.</param>
        /// <param name="version">The current version of the byte value.</param>
        /// <param name="value">The value to add.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="key"/> has a length of 0 or greater than 65536 UTF-8 bytes.</para>
        /// <para>-OR-</para>
        /// <para><paramref name="version"/> is 0.</para>
        /// </exception>
        public FormatEntry(string key, ushort version, double value)
            : this(key, version)
        {
            Add(value);
        }

        internal FormatEntry(BinaryReader reader)
        {
            int strLen = reader.ReadUInt16();
            if (strLen == 0) strLen = DieFledermausStream.Max16Bit;
            _key = TextEncoding.GetString(DieFledermausStream.ReadBytes(reader, strLen));
            _version = reader.ReadUInt16();
            if (_version == 0)
                throw new InvalidDataException();
            int itemCount = reader.ReadUInt16();

            _values = new List<FormatValue>(itemCount);

            for (int i = 0; i < itemCount; i++)
                _values.Add(new FormatValue(DieFledermausStream.ReadBytes16Bit(reader)));
        }
        #endregion

        /// <summary>
        /// Gets and sets the element at the specified index.
        /// </summary>
        /// <param name="index">The index of the element to get or set.</param>
        /// <returns>The element at <paramref name="index"/>.</returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index"/> is less than 0 or is greater than or equal to <see cref="Count"/>.
        /// </exception>
        public FormatValue this[int index]
        {
            get { return _values[index]; }
            set { _values[index] = value; }
        }

        object IList.this[int index]
        {
            get { return _values[index]; }
            set { ((IList)_values)[index] = value; }
        }

        private string _key;
        /// <summary>
        /// Gets the key of the current entry.
        /// </summary>
        public string Key { get { return _key; } }

        private ushort _version;
        /// <summary>
        /// Gets the version number of the current entry.
        /// </summary>
        public ushort Version { get { return _version; } }

        /// <summary>
        /// Gets the number of elements contained in the list.
        /// </summary>
        public int Count
        {
            get { return _values.Count; }
        }

        /// <summary>
        /// Gets a value indicating whether <see cref="Count"/> is equal to the maximum value of 65535.
        /// </summary>
        public bool AtMaximumCapacity
        {
            get { return _values.Count >= ushort.MaxValue; }
        }
        bool ICollection<FormatValue>.IsReadOnly { get { return AtMaximumCapacity; } }
        bool IList.IsReadOnly { get { return AtMaximumCapacity; } }

        /// <summary>
        /// Returns an array containing all elements in the new list.
        /// </summary>
        /// <returns>An array containing all elements in the new list.</returns>
        public FormatValue[] ToArray()
        {
            return _values.ToArray();
        }

        #region Add
        /// <summary>
        /// Adds the specified value to the list.
        /// </summary>
        /// <param name="value">The value to add.</param>
        /// <exception cref="ArgumentException">
        /// The <see cref="FormatValue.Value"/> property is <see langword="null"/>.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Add(FormatValue value)
        {
            Insert(_values.Count, value);
        }

        int IList.Add(object value)
        {
            if (AtMaximumCapacity) return -1;
            int newDex = _values.Count;

            ((IList)this).Insert(_values.Count, value);
            return newDex;
        }

        /// <summary>
        /// Adds the specified value to the list.
        /// </summary>
        /// <param name="value">The value to add.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="value"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="value"/> has a length of 0 or greater than 65536.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Add(byte[] value)
        {
            if (value == null)
                throw new ArgumentNullException(nameof(value));
            Add(new FormatValue(value));
        }

        /// <summary>
        /// Adds the specified value to the list.
        /// </summary>
        /// <param name="s">The value to add.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="s"/> has a length of 0 or greater than 65536 UTF-8 bytes.
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="s"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="EncoderFallbackException">
        /// <paramref name="s"/> contains invalid characters.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Add(string s)
        {
            Add(new FormatValue(s));
        }

        /// <summary>
        /// Adds the specified value to the list.
        /// </summary>
        /// <param name="value">The value to add.</param>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Add(short value)
        {
            Add(new FormatValue(value));
        }

        /// <summary>
        /// Adds the specified value to the list.
        /// </summary>
        /// <param name="value">The value to add.</param>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Add(ushort value)
        {
            Add(new FormatValue(value));
        }

        /// <summary>
        /// Adds the specified value to the list.
        /// </summary>
        /// <param name="value">The value to add.</param>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Add(int value)
        {
            Add(new FormatValue(value));
        }

        /// <summary>
        /// Adds the specified value to the list.
        /// </summary>
        /// <param name="value">The value to add.</param>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Add(uint value)
        {
            Add(new FormatValue(value));
        }

        /// <summary>
        /// Adds the specified value to the list.
        /// </summary>
        /// <param name="value">The value to add.</param>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Add(long value)
        {
            Add(new FormatValue(value));
        }

        /// <summary>
        /// Adds the specified value to the list.
        /// </summary>
        /// <param name="value">The value to add.</param>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Add(ulong value)
        {
            Add(new FormatValue(value));
        }

        /// <summary>
        /// Adds the specified value to the list.
        /// </summary>
        /// <param name="value">The value to add.</param>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Add(float value)
        {
            Add(new FormatValue(value));
        }

        /// <summary>
        /// Adds the specified value to the list.
        /// </summary>
        /// <param name="value">The value to add.</param>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Add(double value)
        {
            Add(new FormatValue(value));
        }
        #endregion

        #region Insert
        /// <summary>
        /// Inserts the specified value into the list at the specified index.
        /// </summary>
        /// <param name="index">The index of the value to add.</param>
        /// <param name="value">The value to add.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index"/> is less than 0 or is greater than <see cref="Count"/>.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// The <see cref="FormatValue.Value"/> property is <see langword="null"/>.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Insert(int index, FormatValue value)
        {
            if (value.Value == null)
                throw new ArgumentException(string.Format(TextResources.PropertyNull, nameof(FormatValue) + "." + nameof(FormatValue.Value)), nameof(value));

            if (AtMaximumCapacity)
                throw new NotSupportedException(TextResources.ByteListAtMaximum);

            _values.Insert(index, value);
        }

        void IList.Insert(int index, object value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));

            if (AtMaximumCapacity)
                throw new NotSupportedException(TextResources.ByteListAtMaximum);

            ((IList)_values).Insert(index, value);
        }

        /// <summary>
        /// Inserts the specified value into the list at the specified index.
        /// </summary>
        /// <param name="index">The index of the value to add.</param>
        /// <param name="value">The value to add.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than 0 or is greater than <see cref="Count"/>.</para>
        /// <para>-OR-</para>
        /// <para><paramref name="value"/> has a length of 0 or greater than 65536.</para>
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="value"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Insert(int index, byte[] value)
        {
            Insert(index, new FormatValue(value));
        }

        /// <summary>
        /// Inserts the specified value into the list at the specified index.
        /// </summary>
        /// <param name="index">The index of the value to add.</param>
        /// <param name="s">The value to add.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than 0 or is greater than <see cref="Count"/>.</para>
        /// <para>-OR-</para>
        /// <para><paramref name="s"/> has a length of 0 or greater than 65536 UTF-8 bytes.</para>
        /// </exception>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="s"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="EncoderFallbackException">
        /// <paramref name="s"/> contains invalid characters.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Insert(int index, string s)
        {
            Insert(index, new FormatValue(s));
        }

        /// <summary>
        /// Inserts the specified value into the list at the specified index.
        /// </summary>
        /// <param name="index">The index of the value to add.</param>
        /// <param name="value">The value to add.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index"/> is less than 0 or is greater than <see cref="Count"/>.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Insert(int index, short value)
        {
            Insert(index, new FormatValue(value));
        }

        /// <summary>
        /// Inserts the specified value into the list at the specified index.
        /// </summary>
        /// <param name="index">The index of the value to add.</param>
        /// <param name="value">The value to add.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index"/> is less than 0 or is greater than <see cref="Count"/>.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Insert(int index, ushort value)
        {
            Insert(index, new FormatValue(value));
        }

        /// <summary>
        /// Inserts the specified value into the list at the specified index.
        /// </summary>
        /// <param name="index">The index of the value to add.</param>
        /// <param name="value">The value to add.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index"/> is less than 0 or is greater than <see cref="Count"/>.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Insert(int index, int value)
        {
            Insert(index, new FormatValue(value));
        }

        /// <summary>
        /// Inserts the specified value into the list at the specified index.
        /// </summary>
        /// <param name="index">The index of the value to add.</param>
        /// <param name="value">The value to add.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index"/> is less than 0 or is greater than <see cref="Count"/>.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Insert(int index, uint value)
        {
            Insert(index, new FormatValue(value));
        }

        /// <summary>
        /// Inserts the specified value into the list at the specified index.
        /// </summary>
        /// <param name="index">The index of the value to add.</param>
        /// <param name="value">The value to add.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index"/> is less than 0 or is greater than <see cref="Count"/>.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Insert(int index, long value)
        {
            Insert(index, new FormatValue(value));
        }

        /// <summary>
        /// Inserts the specified value into the list at the specified index.
        /// </summary>
        /// <param name="index">The index of the value to add.</param>
        /// <param name="value">The value to add.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index"/> is less than 0 or is greater than <see cref="Count"/>.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Insert(int index, ulong value)
        {
            Insert(index, new FormatValue(value));
        }

        /// <summary>
        /// Inserts the specified value into the list at the specified index.
        /// </summary>
        /// <param name="index">The index of the value to add.</param>
        /// <param name="value">The value to add.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index"/> is less than 0 or is greater than <see cref="Count"/>.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Insert(int index, float value)
        {
            Insert(index, new FormatValue(value));
        }

        /// <summary>
        /// Inserts the specified value into the list at the specified index.
        /// </summary>
        /// <param name="index">The index of the value to add.</param>
        /// <param name="value">The value to add.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index"/> is less than 0 or is greater than <see cref="Count"/>.
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <see cref="AtMaximumCapacity"/> is <see langword="true"/>.
        /// </exception>
        public void Insert(int index, double value)
        {
            Insert(index, new FormatValue(value));
        }
        #endregion

        /// <summary>
        /// Removes the specified element from the list.
        /// </summary>
        /// <param name="value">The element to remove from the list.</param>
        /// <returns><see langword="true"/> if <paramref name="value"/> was found and successfully removed; <see langword="false"/> otherwise.</returns>
        public bool Remove(FormatValue value)
        {
            return _values.Remove(value);
        }

        void IList.Remove(object value)
        {
            ((IList)_values).Remove(value);
        }

        /// <summary>
        /// Gets a value indicating whether the specified element exists in the list.
        /// </summary>
        /// <param name="value">The element to search for in the list.</param>
        /// <returns><see langword="true"/> if <paramref name="value"/> was found; <see langword="false"/> otherwise.</returns>
        public bool Contains(FormatValue value)
        {
            return _values.Contains(value);
        }

        bool IList.Contains(object value)
        {
            return ((IList)_values).Contains(value);
        }

        /// <summary>
        /// Returns the index in the list of the specified value.
        /// </summary>
        /// <param name="value">The value to search for in the list.</param>
        /// <returns>The index of <paramref name="value"/>, if found; otherwise, -1.</returns>
        public int IndexOf(FormatValue value)
        {
            return _values.IndexOf(value);
        }

        int IList.IndexOf(object value)
        {
            return ((IList)_values).IndexOf(value);
        }

        /// <summary>
        /// Removes the element at the specified index.
        /// </summary>
        /// <param name="index">The index of the element to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="index"/> is less than 0 or is greater than or equal to <see cref="Count"/>.
        /// </exception>
        public void RemoveAt(int index)
        {
            _values.RemoveAt(index);
        }

        /// <summary>
        /// Removes all elements in the list.
        /// </summary>
        public void Clear()
        {
            _values.Clear();
        }

        internal long GetSize()
        {
            long total = 6L //String prefix + version + count
                + TextEncoding.GetByteCount(_key);

            for (int i = 0; i < _values.Count; i++)
                total += 2L + _values[i].Value.Length;

            return total;
        }

        /// <summary>
        /// Copies all elements in the current instance to the specified array.
        /// </summary>
        /// <param name="array">The array to which the current instance will be copied.</param>
        /// <param name="arrayIndex">The index in <paramref name="array"/> at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="arrayIndex"/> plus <see cref="Count"/> is greater than the number of elements in <paramref name="array"/>.
        /// </exception>
        public void CopyTo(FormatValue[] array, int arrayIndex)
        {
            _values.CopyTo(array, arrayIndex);
        }

        void ICollection.CopyTo(Array array, int index)
        {
            ((ICollection)_values).CopyTo(array, index);
        }

        internal void Write(BinaryWriter writer)
        {
            byte[] keyBytes = TextEncoding.GetBytes(_key);
            writer.Write((ushort)keyBytes.Length);
            writer.Write(keyBytes);
            writer.Write(_version);
            int count = Count;
            writer.Write((ushort)count);
            var values = _values;
            for (int i = 0; i < count; i++)
            {
                var curBytes = values[i].Value;
                writer.Write((ushort)curBytes.Length);
                writer.Write(curBytes);
            }
        }

        /// <summary>
        /// Returns an enumerator which iterates through the list.
        /// </summary>
        /// <returns>An enumerator which iterates through the list.</returns>
        public Enumerator GetEnumerator()
        {
            return new Enumerator(this);
        }

        IEnumerator<FormatValue> IEnumerable<FormatValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        /// <summary>
        /// Returns a string representation of the current instance.
        /// </summary>
        /// <returns>A string representation of the current instance.</returns>
        public override string ToString()
        {
            return string.Format("Key = {0}, Version = {1}, Count = {2}", _key, _version, Count);
        }

        bool ICollection.IsSynchronized { get { return false; } }
        object ICollection.SyncRoot { get { return ((ICollection)_values).SyncRoot; } }
        bool IList.IsFixedSize { get { return false; } }

        /// <summary>
        /// An enumerator which iterates through the list.
        /// </summary>
        public struct Enumerator : IEnumerator<FormatValue>
        {
            private IEnumerator<FormatValue> _enum;
            private FormatValue _current;

            internal Enumerator(FormatEntry fVal)
            {
                _enum = fVal._values.GetEnumerator();
                _current = default(FormatValue);
            }

            /// <summary>
            /// Gets the element at the current position in the enumerator.
            /// </summary>
            public FormatValue Current
            {
                get { return _current; }
            }

            object IEnumerator.Current
            {
                get { return _current; }
            }

            /// <summary>
            /// Disposes of the current instance.
            /// </summary>
            public void Dispose()
            {
                this = default(Enumerator);
            }

            /// <summary>
            /// Advances the enumerator to the next position in the list.
            /// </summary>
            /// <returns><see langword="true"/> if the enumerator was successfully advanced; <see langword="false"/> if the
            /// enumerator has passed the end of the collection.</returns>
            public bool MoveNext()
            {
                if (_enum == null) return false;
                if (_enum.MoveNext())
                {
                    _current = _enum.Current;
                    return true;
                }
                Dispose();
                return false;
            }

            void IEnumerator.Reset()
            {
                _enum.Reset();
            }
        }

        private class DebugView
        {
            private FormatEntry _optionList;

            public DebugView(FormatEntry optionList)
            {
                _optionList = optionList;
            }

            [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
            public FormatValue[] Items
            {
                get { return _optionList.ToArray(); }
            }
        }
    }

    /// <summary>
    /// A read-only wrapper for a <see cref="FormatEntry"/>.
    /// </summary>
    public class ReadOnlyFormatEntry : IList<FormatValue>, IList
#if IREADONLY
        , IReadOnlyList<FormatValue>
#endif
    {
        private FormatEntry _list;

        /// <summary>
        /// Creates a new instance wrapped around the specified <see cref="FormatEntry"/> object.
        /// </summary>
        /// <param name="collection">The <see cref="FormatEntry"/> to wrap around.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="collection"/> is <see langword="null" />.
        /// </exception>
        public ReadOnlyFormatEntry(FormatEntry collection)
        {
            if (collection == null) throw new ArgumentNullException(nameof(collection));
            _list = collection;
        }

        /// <summary>
        /// Gets the element at the specified index.
        /// </summary>
        public FormatValue this[int index]
        {
            get { return _list[index]; }
        }

        FormatValue IList<FormatValue>.this[int index]
        {
            get { return _list[index]; }
            set { throw new NotSupportedException(); }
        }

        object IList.this[int index]
        {
            get { return _list[index]; }
            set { throw new NotSupportedException(); }
        }

        /// <summary>
        /// Gets the number of elements contained in the list.
        /// </summary>
        public int Count { get { return _list.Count; } }

        /// <summary>
        /// Gets the key of the current entry.
        /// </summary>
        public string Key { get { return _list.Key; } }

        /// <summary>
        /// Gets the version number of the current entry.
        /// </summary>
        public ushort Version { get { return _list.Version; } }

        /// <summary>
        /// Gets a value indicating whether <see cref="Count"/> is equal to the maximum value of 65535.
        /// </summary>
        public bool AtMaximumCapacity { get { return _list.AtMaximumCapacity; } }

        /// <summary>
        /// Gets a value indicating whether the specified element exists in the list.
        /// </summary>
        /// <param name="value">The element to search for in the list.</param>
        /// <returns><see langword="true"/> if <paramref name="value"/> was found; <see langword="false"/> otherwise.</returns>
        public bool Contains(FormatValue value)
        {
            return _list.Contains(value);
        }

        bool IList.Contains(object value)
        {
            return ((IList)_list).Contains(value);
        }

        /// <summary>
        /// Returns the index in the list of the specified value.
        /// </summary>
        /// <param name="value">The value to search for in the list.</param>
        /// <returns>The index of <paramref name="value"/>, if found; otherwise, -1.</returns>
        public int IndexOf(FormatValue value)
        {
            return _list.IndexOf(value);
        }

        int IList.IndexOf(object value)
        {
            return ((IList)_list).IndexOf(value);
        }

        /// <summary>
        /// Copies all elements in the current instance to the specified array.
        /// </summary>
        /// <param name="array">The array to which the current instance will be copied.</param>
        /// <param name="arrayIndex">The index in <paramref name="array"/> at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentException">
        /// <paramref name="arrayIndex"/> plus <see cref="Count"/> is greater than the number of elements in <paramref name="array"/>.
        /// </exception>
        public void CopyTo(FormatValue[] array, int arrayIndex)
        {
            _list.CopyTo(array, arrayIndex);
        }

        void ICollection.CopyTo(Array array, int index)
        {
            ((ICollection)_list).CopyTo(array, index);
        }

        /// <summary>
        /// Returns an array containing all elements in the list.
        /// </summary>
        /// <returns>An array containing all elements in the list.</returns>
        public FormatValue[] ToArray()
        {
            return _list.ToArray();
        }

        bool ICollection<FormatValue>.IsReadOnly { get { return true; } }
        bool IList.IsReadOnly { get { return true; } }
        bool IList.IsFixedSize { get { return false; } }
        bool ICollection.IsSynchronized { get { return false; } }
        object ICollection.SyncRoot { get { return ((ICollection)_list).SyncRoot; } }

        /// <summary>
        /// Returns an enumerator which iterates through the list.
        /// </summary>
        /// <returns>An enumerator which iterates through the list.</returns>
        public FormatEntry.Enumerator GetEnumerator()
        {
            return _list.GetEnumerator();
        }

        IEnumerator<FormatValue> IEnumerable<FormatValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        #region Not Supported
        void ICollection<FormatValue>.Add(FormatValue value)
        {
            throw new NotSupportedException();
        }

        int IList.Add(object value)
        {
            throw new NotSupportedException();
        }

        bool ICollection<FormatValue>.Remove(FormatValue value)
        {
            throw new NotSupportedException();
        }

        void IList.Remove(object value)
        {
            throw new NotSupportedException();
        }

        void ICollection<FormatValue>.Clear()
        {
            throw new NotSupportedException();
        }

        void IList.Clear()
        {
            throw new NotSupportedException();
        }

        void IList<FormatValue>.Insert(int index, FormatValue value)
        {
            throw new NotSupportedException();
        }

        void IList.Insert(int index, object value)
        {
            throw new NotSupportedException();
        }

        void IList<FormatValue>.RemoveAt(int index)
        {
            throw new NotSupportedException();
        }

        void IList.RemoveAt(int index)
        {
            throw new NotSupportedException();
        }
        #endregion
    }

    /// <summary>
    /// Represents a single element of a format value.
    /// </summary>
    public struct FormatValue : IEquatable<FormatValue>
    {
        #region Constructors
        /// <summary>
        /// Creates a new instance using the specified binary value.
        /// </summary>
        /// <param name="value">The value to set.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="value"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="value"/> has a length of 0 or greater than 65536.
        /// </exception>
        public FormatValue(byte[] value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));
            if (value.Length == 0 || value.Length > DieFledermausStream.Max16Bit)
                throw new ArgumentOutOfRangeException(nameof(value), value, TextResources.OutOfRangeByteLength);
            _value = (byte[])value.Clone();
        }

        /// <summary>
        /// Creates a new instance using the specified value.
        /// </summary>
        /// <param name="s">The value to set.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="s"/> is <see langword="null"/>.
        /// </exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="s"/> has a length of 0 or greater than 65536 UTF-8 bytes.
        /// </exception>
        /// <exception cref="EncoderFallbackException">
        /// <paramref name="s"/> contains invalid characters.
        /// </exception>
        public FormatValue(string s)
        {
            if (FormatEntry.TextEncoding.GetByteCount(s) > DieFledermausStream.Max16Bit || s.Length == 0)
                throw new ArgumentOutOfRangeException(nameof(s), s, TextResources.CommentLength);
            _value = FormatEntry.TextEncoding.GetBytes(s);
        }

        /// <summary>
        /// Creates a new instance using the specified value.
        /// </summary>
        /// <param name="value">The value to set.</param>
        public FormatValue(short value)
        {
            _value = new byte[] { (byte)value, (byte)(value >> 8) };
        }

        /// <summary>
        /// Creates a new instance using the specified value.
        /// </summary>
        /// <param name="value">The value to set.</param>
        public FormatValue(ushort value)
        {
            _value = new byte[] { (byte)value, (byte)(value >> 8) };
        }

        /// <summary>
        /// Creates a new instance using the specified value.
        /// </summary>
        /// <param name="value">The value to set.</param>
        public FormatValue(int value)
        {
            _value = new byte[] { (byte)value, (byte)(value >> 8), (byte)(value >> 16), (byte)(value >> 24) };
        }

        /// <summary>
        /// Creates a new instance using the specified value.
        /// </summary>
        /// <param name="value">The value to set.</param>
        public FormatValue(uint value)
        {
            _value = new byte[] { (byte)value, (byte)(value >> 8), (byte)(value >> 16), (byte)(value >> 24) };
        }

        /// <summary>
        /// Creates a new instance using the specified value.
        /// </summary>
        /// <param name="value">The value to set.</param>
        public FormatValue(long value)
        {
            _value = new byte[] { (byte)value, (byte)(value >> 8), (byte)(value >> 16), (byte)(value >> 24),
                (byte)(value >> 32), (byte)(value >> 40), (byte)(value >> 48), (byte)(value >> 56) };
        }

        /// <summary>
        /// Creates a new instance using the specified value.
        /// </summary>
        /// <param name="value">The value to set.</param>
        public FormatValue(ulong value)
        {
            _value = new byte[] { (byte)value, (byte)(value >> 8), (byte)(value >> 16), (byte)(value >> 24),
                (byte)(value >> 32), (byte)(value >> 40), (byte)(value >> 48), (byte)(value >> 56) };
        }

        /// <summary>
        /// Creates a new instance using the specified value.
        /// </summary>
        /// <param name="value">The value to set.</param>
        public FormatValue(float value)
            : this(BufferConvert<float, int>(value, sizeof(float)))
        {
        }

        /// <summary>
        /// Creates a new instance using the specified value.
        /// </summary>
        /// <param name="value">The value to set.</param>
        public FormatValue(double value)
            : this(BufferConvert<double, long>(value, sizeof(double)))
        {
        }

        private static TOut BufferConvert<TIn, TOut>(TIn value, int size)
        {
            TIn[] inBuffer = new TIn[] { value };
            TOut[] outBuffer = new TOut[1];
            Buffer.BlockCopy(inBuffer, 0, outBuffer, 0, size);
            return outBuffer[0];
        }
        #endregion

        #region Values
        private byte[] _value;
        /// <summary>
        /// Gets the binary value of the current instance.
        /// </summary>
        public byte[] Value
        {
            get
            {
                if (_value == null) return null;
                return (byte[])_value.Clone();
            }
        }

        /// <summary>
        /// Gets the string representation of <see cref="Value"/>, or <see langword="null"/> if <see cref="Value"/> contains invalid UTF-8 bytes.
        /// </summary>
        public string ValueString
        {
            get
            {
                if (_value == null) return null;
                try
                {
                    return FormatEntry.TextEncoding.GetString(_value);
                }
                catch
                {
                    return null;
                }
            }
        }
        /// <summary>
        /// Gets a signed 16 integer representation of <see cref="Value"/>, or <see langword="null"/> if <see cref="Value"/>
        /// does not have a length of 2.
        /// </summary>
        public short? ValueInt16
        {
            get
            {
                if (_value == null || _value.Length != sizeof(short)) return null;
                return (short)(_value[0] | ((short)_value[1] << 8));
            }
        }

        /// <summary>
        /// Gets an unsigned 16 integer representation of <see cref="Value"/>, or <see langword="null"/> if <see cref="Value"/>
        /// does not have a length of 2.
        /// </summary>
        public ushort? ValueUInt16
        {
            get
            {
                if (_value == null || _value.Length != sizeof(ushort)) return null;
                return (ushort)(_value[0] | ((ushort)_value[1] << 8));
            }
        }

        /// <summary>
        /// Gets a signed 32 integer representation of <see cref="Value"/>, or <see langword="null"/> if <see cref="Value"/>
        /// does not have a length of 4.
        /// </summary>
        public int? ValueInt32
        {
            get
            {
                if (_value == null || _value.Length != sizeof(int)) return null;
                return (int)(_value[0] | ((int)_value[1] << 8) | ((int)_value[2] << 16) | ((int)_value[3] << 24));
            }
        }

        /// <summary>
        /// Gets an unsigned 32 integer representation of <see cref="Value"/>, or <see langword="null"/> if <see cref="Value"/>
        /// does not have a length of 4.
        /// </summary>
        public uint? ValueUInt32
        {
            get
            {
                if (_value == null || _value.Length != sizeof(uint)) return null;
                return (uint)(_value[0] | ((uint)_value[1] << 8) | ((uint)_value[2] << 16) | ((uint)_value[3] << 24));
            }
        }

        /// <summary>
        /// Gets a signed 64 integer representation of <see cref="Value"/>, or <see langword="null"/> if <see cref="Value"/>
        /// does not have a length of 8.
        /// </summary>
        public long? ValueInt64
        {
            get
            {
                if (_value == null || _value.Length != sizeof(long)) return null;
                return (long)(_value[0] | ((long)_value[1] << 8) | ((long)_value[2] << 16) | ((long)_value[3] << 24) |
                    ((long)_value[4] << 32) | ((long)_value[5] << 40) | ((long)_value[6] << 48) | ((long)_value[7] << 56));
            }
        }

        /// <summary>
        /// Gets an unsigned 64 integer representation of <see cref="Value"/>, or <see langword="null"/> if <see cref="Value"/>
        /// does not have a length of 8.
        /// </summary>
        public ulong? ValueUInt64
        {
            get
            {
                if (_value == null || _value.Length != sizeof(ulong)) return null;
                return (ulong)(_value[0] | ((ulong)_value[1] << 8) | ((ulong)_value[2] << 16) | ((ulong)_value[3] << 24) |
                    ((ulong)_value[4] << 32) | ((ulong)_value[5] << 40) | ((ulong)_value[6] << 48) | ((ulong)_value[7] << 56));
            }
        }

        /// <summary>
        /// Gets double-precision floating-point value representation of <see cref="Value"/>, or <see langword="null"/> if <see cref="Value"/>
        /// does not have a length of 4.
        /// </summary>
        public float? ValueSingle
        {
            get
            {
                int? value = ValueInt32;
                if (value == null) return null;
                return BufferConvert<int, float>(value.Value, sizeof(float));
            }
        }

        /// <summary>
        /// Gets single-precision floating-point value representation of <see cref="Value"/>, or <see langword="null"/> if <see cref="Value"/>
        /// does not have a length of 8.
        /// </summary>
        public double? ValueDouble
        {
            get
            {
                long? value = ValueInt64;
                if (value == null) return null;
                return BufferConvert<long, double>(value.Value, sizeof(double));
            }
        }
        #endregion

        /// <summary>
        /// Returns a string representation of the current value.
        /// </summary>
        /// <returns>A string representation of the current value.</returns>
        public override string ToString()
        {
            if (_value == null)
                return base.ToString();

            string s = ValueString;
            if (s != null && ((_value.Length != sizeof(short) && _value.Length != sizeof(int) && _value.Length != sizeof(long)) || !s.Any(c => char.IsControl(c) && !char.IsWhiteSpace(c))))
                return s;

            short? valInt16 = ValueInt16;
            if (valInt16.HasValue)
                return valInt16.Value.ToString(NumberFormatInfo.InvariantInfo);

            int? valInt32 = ValueInt32;
            if (valInt32.HasValue)
                return valInt32.Value.ToString(NumberFormatInfo.InvariantInfo);

            long? valInt64 = ValueInt64;
            if (valInt64.HasValue)
                return valInt64.Value.ToString(NumberFormatInfo.InvariantInfo);

            return string.Concat(_value.Select(i => i.ToString("x2", NumberFormatInfo.InvariantInfo)).ToArray());
        }

        #region Equality
        /// <summary>
        /// Determines if the current value is equal to the specified other <see cref="FormatValue"/> object.
        /// </summary>
        /// <param name="other">The other <see cref="FormatValue"/> to compare.</param>
        /// <returns><see langword="true"/> if the current instance is equal to <paramref name="other"/>; <see langword="false"/> otherwise.</returns>
        public bool Equals(FormatValue other)
        {
            if (_value == other._value) return true;
            int length = (_value == null) ? 0 : _value.Length;

            if ((length != 0 && other._value == null) || length != other._value.Length)
                return false;

            for (int i = 0; i < length; i++)
            {
                if (_value[i] != other._value[i])
                    return false;
            }
            return true;
        }

        /// <summary>
        /// Determines if the current value is equal to the specified other object.
        /// </summary>
        /// <param name="obj">The other object to compare.</param>
        /// <returns><see langword="true"/> if <paramref name="obj"/> is a <see cref="FormatValue"/> equal to the current instance;
        /// <see langword="false"/> otherwise.</returns>
        public override bool Equals(object obj)
        {
            return obj is FormatValue && Equals((FormatValue)obj);
        }

        /// <summary>
        /// Returns the hash code for the current value.
        /// </summary>
        /// <returns>The hash code for the current value.</returns>
        public override int GetHashCode()
        {
            if (_value == null) return 0;
            int total = 0;
            for (int i = 0; i < _value.Length; i++)
                total += _value[i];
            return total;
        }

        /// <summary>
        /// Determines equality of two <see cref="FormatValue"/> objects.
        /// </summary>
        /// <param name="b1">A <see cref="FormatValue"/> to compare.</param>
        /// <param name="b2">A <see cref="FormatValue"/> to compare.</param>
        /// <returns><see langword="true"/> if <paramref name="b1"/> is equal to <paramref name="b2"/>; <see langword="false"/> otherwise.</returns>
        public static bool operator ==(FormatValue b1, FormatValue b2)
        {
            return b1.Equals(b2);
        }

        /// <summary>
        /// Determines inequality of two <see cref="FormatValue"/> objects.
        /// </summary>
        /// <param name="b1">A <see cref="FormatValue"/> to compare.</param>
        /// <param name="b2">A <see cref="FormatValue"/> to compare.</param>
        /// <returns><see langword="true"/> if <paramref name="b1"/> is not equal to <paramref name="b2"/>; <see langword="false"/> otherwise.</returns>
        public static bool operator !=(FormatValue b1, FormatValue b2)
        {
            return !b1.Equals(b2);
        }
        #endregion
    }
}
